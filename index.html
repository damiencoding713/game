<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Second Chance: Life Run</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Nunito:wght@400;600;700&display=swap"
    rel="stylesheet"
  />
  <style>
    :root {
      color-scheme: dark;
      --bg: #04060f;
      --panel: rgba(14, 18, 34, 0.9);
      --accent: #ff3b5f;
      --accent-soft: rgba(255, 59, 95, 0.25);
      --good: #3dffb0;
      --warn: #ffd064;
      --text: #f6f7ff;
      --blue: #62d5ff;
      --purple: #846bff;
      --shadow: rgba(3, 6, 18, 0.65);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #1b2038 0%, var(--bg) 58%);
      color: var(--text);
      font-family: "Nunito", sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    h1, h2, h3 {
      font-family: "Space Grotesk", sans-serif;
    }

    .stage {
      width: min(1220px, 94vw);
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 24px;
    }

    .scene,
    .hud {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 22px;
      padding: 22px;
      box-shadow: 0 18px 40px var(--shadow);
      backdrop-filter: blur(16px);
      position: relative;
    }

    .scene {
      min-height: 560px;
      overflow: hidden;
    }

    .glow {
      position: absolute;
      inset: -40%;
      background: radial-gradient(circle, rgba(132, 107, 255, 0.3), transparent 60%);
      opacity: 0.4;
      animation: glow 4s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes glow {
      0%, 100% { transform: scale(0.96); opacity: 0.3; }
      50% { transform: scale(1.08); opacity: 0.6; }
    }

    .status-bar {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
    }

    .status-block {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      padding: 12px 14px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .status-block h4 {
      margin: 0 0 8px;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      opacity: 0.65;
    }

    .meter {
      height: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
      position: relative;
    }

    .meter span {
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, var(--good), var(--warn), var(--accent));
      transform-origin: left;
      transition: transform 0.2s ease;
    }

    .value {
      font-size: 1.2rem;
      font-weight: 700;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      margin-top: 10px;
      font-size: 0.9rem;
      opacity: 0.85;
    }

    .stat-row span {
      font-weight: 700;
      color: var(--blue);
    }

    .alert {
      margin-top: 16px;
      padding: 16px 18px;
      border-radius: 16px;
      background: rgba(255, 59, 95, 0.08);
      border: 1px solid rgba(255, 59, 95, 0.35);
    }

    .alert h3 {
      margin: 0 0 6px;
    }

    .alert p {
      margin: 0;
      opacity: 0.85;
      line-height: 1.4;
    }

    .objective {
      margin-top: 12px;
      padding: 12px 14px;
      border-radius: 14px;
      background: rgba(98, 213, 255, 0.12);
      border: 1px solid rgba(98, 213, 255, 0.35);
      font-size: 0.9rem;
    }

    .objective strong {
      color: var(--blue);
    }

    .arena {
      position: relative;
      width: 100%;
      height: 430px;
      margin-top: 20px;
      border-radius: 18px;
      background: linear-gradient(145deg, rgba(10, 15, 30, 0.95), rgba(6, 9, 18, 0.95));
      border: 1px solid rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .grid-lines {
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(rgba(255, 255, 255, 0.04) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.04) 1px, transparent 1px);
      background-size: 50px 50px;
      opacity: 0.45;
      pointer-events: none;
    }

    .player {
      position: absolute;
      width: 56px;
      height: 56px;
      border-radius: 18px;
      background: radial-gradient(circle at 30% 20%, #ffe7d4, #f4b58a 70%);
      border: 2px solid rgba(255, 255, 255, 0.35);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.45);
      display: grid;
      place-items: center;
      transition: transform 0.1s ease;
    }

    .player .face {
      width: 30px;
      height: 18px;
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.12);
      position: relative;
    }

    .player .face::before,
    .player .face::after {
      content: "";
      position: absolute;
      top: 4px;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #201b1b;
    }

    .player .face::before { left: 5px; }
    .player .face::after { right: 5px; }

    .player.baby {
      width: 50px;
      height: 50px;
      border-radius: 18px;
      background: radial-gradient(circle at 30% 20%, #fff0e5, #f9bba3 70%);
    }

    .player.kid {
      width: 58px;
      height: 58px;
      background: radial-gradient(circle at 30% 20%, #ffd5b5, #f0a576 70%);
    }

    .player.adult {
      width: 62px;
      height: 62px;
      background: radial-gradient(circle at 30% 20%, #ffd7ac, #d4925c 70%);
    }

    .player.elder {
      width: 66px;
      height: 66px;
      background: radial-gradient(circle at 30% 20%, #f5e1c9, #a97c50 70%);
      box-shadow: 0 0 22px rgba(255, 208, 100, 0.35);
    }

    .player.boost {
      transform: scale(1.08);
    }

    .player.shielded {
      box-shadow: 0 0 28px rgba(98, 213, 255, 0.85);
      outline: 2px solid rgba(98, 213, 255, 0.85);
    }

    .orb {
      position: absolute;
      width: 28px;
      height: 28px;
      border-radius: 50%;
    }

    .orb.good {
      background: radial-gradient(circle at 30% 20%, #ffffff, #58ffd0 65%);
      box-shadow: 0 0 14px rgba(61, 255, 176, 0.7);
    }

    .orb.xp {
      background: radial-gradient(circle at 30% 20%, #ffffff, #7bff8a 65%);
      box-shadow: 0 0 14px rgba(61, 255, 176, 0.7);
    }

    .orb.time {
      background: radial-gradient(circle at 30% 20%, #ffffff, #8b6bff 65%);
      box-shadow: 0 0 14px rgba(132, 107, 255, 0.7);
    }

    .orb.energy {
      background: radial-gradient(circle at 30% 20%, #ffffff, #62d5ff 65%);
      box-shadow: 0 0 14px rgba(98, 213, 255, 0.7);
    }

    .orb.choice {
      background: radial-gradient(circle at 30% 20%, #ffffff, #ffd064 65%);
      box-shadow: 0 0 16px rgba(255, 208, 100, 0.7);
    }

    .orb.bad {
      background: radial-gradient(circle at 30% 20%, #ff7a91, #c0163b 70%);
      box-shadow: 0 0 16px rgba(255, 59, 95, 0.8);
    }

    .orb.curse {
      background: radial-gradient(circle at 30% 20%, #ffb1c1, #6b1bb0 70%);
      box-shadow: 0 0 16px rgba(132, 107, 255, 0.8);
    }

    .orb::after {
      content: "";
      position: absolute;
      inset: 8px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.7);
    }

    .trail {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(132, 107, 255, 0.4);
      animation: fade 0.6s linear forwards;
      pointer-events: none;
    }

    @keyframes fade {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(2); opacity: 0; }
    }

    .hud h2 {
      margin-top: 0;
      font-size: 1.8rem;
    }

    .controls {
      display: grid;
      gap: 12px;
      margin-top: 18px;
    }

    .control-card {
      padding: 12px 14px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      font-size: 0.92rem;
    }

    .control-card strong {
      color: var(--blue);
    }

    .legend {
      margin-top: 14px;
      display: grid;
      gap: 10px;
      font-size: 0.88rem;
    }

    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .legend i {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--good);
      box-shadow: 0 0 8px rgba(61, 255, 176, 0.6);
    }

    .legend i.bad { background: var(--accent); box-shadow: 0 0 8px rgba(255, 59, 95, 0.6); }
    .legend i.choice { background: var(--warn); box-shadow: 0 0 8px rgba(255, 208, 100, 0.6); }
    .legend i.time { background: var(--purple); box-shadow: 0 0 8px rgba(132, 107, 255, 0.6); }
    .legend i.energy { background: var(--blue); box-shadow: 0 0 8px rgba(98, 213, 255, 0.6); }

    .bonus-list {
      margin: 16px 0 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 10px;
    }

    .bonus-list li {
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(132, 107, 255, 0.08);
      border: 1px solid rgba(132, 107, 255, 0.4);
      font-size: 0.88rem;
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(4, 6, 14, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 10;
    }

    .overlay.active {
      opacity: 1;
      pointer-events: all;
    }

    .panel {
      padding: 24px;
      text-align: center;
      border-radius: 16px;
      background: rgba(10, 13, 24, 0.96);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
      width: min(420px, 92vw);
    }

    .panel button {
      margin-top: 16px;
      padding: 10px 20px;
      border-radius: 10px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
    }

    .choice-panel {
      display: grid;
      gap: 12px;
      margin-top: 14px;
    }

    .choice-panel button {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: var(--text);
    }

    .choice-panel button:hover {
      border-color: rgba(255, 255, 255, 0.3);
    }

    .flash {
      position: absolute;
      inset: 0;
      background: rgba(255, 59, 95, 0.2);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s ease;
    }

    .flash.active {
      opacity: 1;
    }

    @media (max-width: 960px) {
      .stage {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="stage">
    <section class="scene">
      <div class="glow"></div>
      <div class="status-bar">
        <div class="status-block">
          <h4>Alive chance</h4>
          <div class="meter"><span id="aliveMeter"></span></div>
          <div class="stat-row">Energy <span id="energyValue">100</span></div>
        </div>
        <div class="status-block">
          <h4>Seconds saved</h4>
          <div class="value" id="score">0</div>
          <div class="stat-row">XP <span id="xpValue">0</span></div>
        </div>
        <div class="status-block">
          <h4>Stage</h4>
          <div class="value" id="stageLabel">Baby</div>
          <div class="stat-row">Age <span id="ageValue">0</span></div>
        </div>
      </div>
      <div class="alert">
        <h3 id="alertTitle">Breathe. Stay alive.</h3>
        <p id="alertText">Move with WASD or arrows. Dodge bad orbs, collect good ones.</p>
      </div>
      <div class="objective" id="objectiveText">
        <strong>Objective:</strong> Build a 10 XP streak without taking damage.
      </div>

      <div class="arena" id="arena">
        <div class="grid-lines"></div>
        <div class="flash" id="flash"></div>
        <div class="player baby" id="player">
          <div class="face"></div>
        </div>
      </div>
    </section>

    <section class="hud">
      <h2>Second Chance: Life Run</h2>
      <p>
        He starts as a baby. Every decade changes your strengths and weaknesses. Choose
        orbs wisely, trigger abilities, and survive a lifetime of chaos.
      </p>
      <div class="controls">
        <div class="control-card">
          <strong>Move:</strong> Arrow keys / WASD. Holding Shift gives a short burst.
        </div>
        <div class="control-card">
          <strong>Abilities:</strong> <strong>Space</strong> dash, <strong>E</strong> shield,
          <strong>Q</strong> focus (slows time). Energy refills over time.
        </div>
        <div class="control-card">
          <strong>Strategy:</strong> Build XP, spend legacy points on perks, and balance
          speed vs. stamina as you age.
        </div>
      </div>
      <div class="legend">
        <span><i></i> Good orbs: heal, XP, energy, time</span>
        <span><i class="choice"></i> Choice orb: pick a reward or risk</span>
        <span><i class="time"></i> Time orb: slows hazards briefly</span>
        <span><i class="energy"></i> Energy orb: refill energy fast</span>
        <span><i class="bad"></i> Bad orbs: damage, curses, confusion</span>
      </div>
      <ul class="bonus-list">
        <li>Real-life aging: speed peaks as a teen, stamina fades with age.</li>
        <li>Life events appear at milestones and force tough decisions.</li>
        <li>Earn legacy points to unlock perks that persist between runs.</li>
        <li>Random modifiers make every run feel new.</li>
      </ul>
    </section>
  </main>

  <div class="overlay active" id="startOverlay">
    <div class="panel">
      <h3>Keep him alive.</h3>
      <p>Every second matters. Build a legacy that lasts across runs.</p>
      <div class="choice-panel" id="perkPanel"></div>
      <button id="startBtn">Start Life Run</button>
    </div>
  </div>

  <div class="overlay" id="eventOverlay">
    <div class="panel">
      <h3 id="eventTitle">Life Event</h3>
      <p id="eventText">Choose carefully.</p>
      <div class="choice-panel" id="eventChoices"></div>
    </div>
  </div>

  <div class="overlay" id="choiceOverlay">
    <div class="panel">
      <h3>Choice Orb</h3>
      <p id="choiceText">Pick the reward that fits your strategy.</p>
      <div class="choice-panel" id="choiceButtons"></div>
    </div>
  </div>

  <div class="overlay" id="gameOverOverlay">
    <div class="panel">
      <h3>He didn't make it.</h3>
      <p id="finalScore">You saved him for 0 seconds.</p>
      <button id="restartBtn">Try Again</button>
    </div>
  </div>

  <script>
    const arena = document.getElementById("arena");
    const player = document.getElementById("player");
    const aliveMeter = document.getElementById("aliveMeter");
    const scoreEl = document.getElementById("score");
    const xpValue = document.getElementById("xpValue");
    const energyValue = document.getElementById("energyValue");
    const ageValue = document.getElementById("ageValue");
    const stageLabel = document.getElementById("stageLabel");
    const alertTitle = document.getElementById("alertTitle");
    const alertText = document.getElementById("alertText");
    const objectiveText = document.getElementById("objectiveText");
    const flash = document.getElementById("flash");
    const startOverlay = document.getElementById("startOverlay");
    const eventOverlay = document.getElementById("eventOverlay");
    const eventTitle = document.getElementById("eventTitle");
    const eventText = document.getElementById("eventText");
    const eventChoices = document.getElementById("eventChoices");
    const choiceOverlay = document.getElementById("choiceOverlay");
    const choiceText = document.getElementById("choiceText");
    const choiceButtons = document.getElementById("choiceButtons");
    const gameOverOverlay = document.getElementById("gameOverOverlay");
    const finalScore = document.getElementById("finalScore");
    const perkPanel = document.getElementById("perkPanel");
    const startBtn = document.getElementById("startBtn");
    const restartBtn = document.getElementById("restartBtn");

    const storageKey = "life-run-legacy";
    const state = {
      active: false,
      score: 0,
      aliveChance: 1,
      energy: 100,
      xp: 0,
      age: 0,
      playerX: 0,
      playerY: 0,
      speed: 220,
      dashCooldown: 0,
      shieldCooldown: 0,
      focusCooldown: 0,
      shielded: false,
      slowTime: 0,
      orbs: [],
      lastTime: null,
      orbTimer: 0,
      badOrbTimer: 0,
      difficultyTimer: 0,
      streak: 0,
      objectiveIndex: 0,
      eventIndex: 0,
      allowChoices: true,
      perks: new Set(),
      legacyPoints: 0,
      modifier: null,
    };

    const stages = [
      { name: "Baby", start: 0, speed: 200, staminaDrain: 0.8 },
      { name: "Toddler", start: 8, speed: 230, staminaDrain: 1 },
      { name: "Teen", start: 16, speed: 270, staminaDrain: 1.2 },
      { name: "Adult", start: 30, speed: 245, staminaDrain: 1.4 },
      { name: "Elder", start: 60, speed: 220, staminaDrain: 1.7 },
    ];

    const objectives = [
      { text: "Build a 10 XP streak without taking damage.", target: 10, type: "streak" },
      { text: "Collect 6 good orbs in a row.", target: 6, type: "good" },
      { text: "Dodge 14 bad orbs.", target: 14, type: "dodge" },
      { text: "Survive 25 seconds without using dash.", target: 25, type: "nodash" },
    ];

    const events = [
      {
        age: 18,
        title: "Scholarship Offer",
        text: "Study for safety or chase risky glory?",
        choices: [
          { text: "Study", effect: () => gainStat("alive", 0.15) },
          { text: "Chase glory", effect: () => gainStat("xp", 25) },
        ],
      },
      {
        age: 30,
        title: "Career Crossroads",
        text: "Stable job or adventurous path?",
        choices: [
          { text: "Stable", effect: () => gainStat("energy", 30) },
          { text: "Adventure", effect: () => gainStat("speed", 15) },
        ],
      },
      {
        age: 45,
        title: "Health Check",
        text: "Invest in fitness or lean on luck?",
        choices: [
          { text: "Fitness", effect: () => gainStat("alive", 0.2) },
          { text: "Luck", effect: () => gainStat("xp", 35) },
        ],
      },
      {
        age: 60,
        title: "Legacy Moment",
        text: "Share wisdom or hoard energy?",
        choices: [
          { text: "Share", effect: () => gainStat("legacy", 2) },
          { text: "Hoard", effect: () => gainStat("energy", 40) },
        ],
      },
    ];

    const perks = [
      { id: "starterShield", label: "Start with a shield", cost: 2 },
      { id: "extraEnergy", label: "+15 max energy", cost: 2 },
      { id: "slowDecay", label: "Slower survival drain", cost: 3 },
      { id: "orbMagnet", label: "Orb magnet radius", cost: 3 },
    ];

    const modifiers = [
      { name: "Stormfall", text: "Bad orbs spawn faster." },
      { name: "Golden Hour", text: "Good orbs are more common." },
      { name: "Low Gravity", text: "Everything moves a bit slower." },
      { name: "High Stakes", text: "XP is doubled, damage is harsher." },
    ];

    const keys = new Set();

    function loadLegacy() {
      const saved = JSON.parse(localStorage.getItem(storageKey) || "{}");
      state.legacyPoints = saved.legacyPoints || 0;
      state.perks = new Set(saved.perks || []);
    }

    function saveLegacy() {
      localStorage.setItem(storageKey, JSON.stringify({
        legacyPoints: state.legacyPoints,
        perks: Array.from(state.perks),
      }));
    }

    function renderPerks() {
      perkPanel.innerHTML = "";
      const title = document.createElement("p");
      title.textContent = `Legacy Points: ${state.legacyPoints}`;
      perkPanel.appendChild(title);
      perks.forEach((perk) => {
        const button = document.createElement("button");
        button.textContent = `${perk.label} (${perk.cost})`;
        button.disabled = state.perks.has(perk.id) || state.legacyPoints < perk.cost;
        button.addEventListener("click", () => {
          if (state.legacyPoints >= perk.cost && !state.perks.has(perk.id)) {
            state.legacyPoints -= perk.cost;
            state.perks.add(perk.id);
            saveLegacy();
            renderPerks();
          }
        });
        perkPanel.appendChild(button);
      });
    }

    function resetPlayerPosition() {
      const rect = arena.getBoundingClientRect();
      state.playerX = rect.width / 2 - player.clientWidth / 2;
      state.playerY = rect.height * 0.65 - player.clientHeight / 2;
      updatePlayer();
    }

    function updatePlayer() {
      player.style.left = `${state.playerX}px`;
      player.style.top = `${state.playerY}px`;
    }

    function spawnOrb(type, className) {
      const orb = document.createElement("div");
      orb.className = `orb ${className}`;
      orb.dataset.type = type;
      const size = 24 + Math.random() * 10;
      orb.style.width = `${size}px`;
      orb.style.height = `${size}px`;
      orb.dataset.speed = (90 + Math.random() * 110).toFixed(2);
      orb.style.left = `${Math.random() * (arena.clientWidth - size)}px`;
      orb.style.top = `-${size}px`;
      arena.appendChild(orb);
      state.orbs.push(orb);
    }

    function spawnGoodOrb() {
      const roll = Math.random();
      if (roll < 0.35) return spawnOrb("heal", "good");
      if (roll < 0.6) return spawnOrb("xp", "xp");
      if (roll < 0.8) return spawnOrb("energy", "energy");
      if (roll < 0.95) return spawnOrb("time", "time");
      return spawnOrb("choice", "choice");
    }

    function spawnBadOrb() {
      const roll = Math.random();
      if (roll < 0.65) return spawnOrb("damage", "bad");
      return spawnOrb("curse", "curse");
    }

    function setStage() {
      const stage = stages.reduce((current, next) =>
        state.age >= next.start ? next : current
      );
      player.classList.remove("baby", "kid", "adult", "elder");
      if (stage.name === "Baby") player.classList.add("baby");
      if (stage.name === "Toddler" || stage.name === "Teen") player.classList.add("kid");
      if (stage.name === "Adult") player.classList.add("adult");
      if (stage.name === "Elder") player.classList.add("elder");
      state.speed = stage.speed + (state.perks.has("orbMagnet") ? 10 : 0);
      stageLabel.textContent = stage.name;
    }

    function handleMovement(delta) {
      const boost = keys.has("Shift") ? 1.3 : 1;
      const speed = state.speed * boost;
      const dir = getDirection();
      if (dir) {
        state.playerX += dir.x * speed * delta;
        state.playerY += dir.y * speed * delta;
        player.classList.add("boost");
        leaveTrail();
      } else {
        player.classList.remove("boost");
      }
      clampPlayer();
      updatePlayer();
    }

    function leaveTrail() {
      const trail = document.createElement("div");
      trail.className = "trail";
      trail.style.left = `${state.playerX + player.clientWidth / 2}px`;
      trail.style.top = `${state.playerY + player.clientHeight / 2}px`;
      arena.appendChild(trail);
      setTimeout(() => trail.remove(), 600);
    }

    function moveOrbs(delta) {
      state.orbs.forEach((orb) => {
        const slow = state.slowTime > 0 ? 0.55 : 1;
        let speed = Number(orb.dataset.speed) * slow;
        if (state.modifier?.name === "Low Gravity") speed *= 0.8;
        if (orb.dataset.type === "damage" && state.modifier?.name === "High Stakes") {
          speed *= 1.2;
        }
        orb.style.top = `${orb.offsetTop + speed * delta}px`;
        if (orb.offsetTop > arena.clientHeight + 40) {
          orb.remove();
          orb._remove = true;
          if (orb.dataset.type === "damage" || orb.dataset.type === "curse") {
            registerObjective("dodge");
          }
        }
        if (checkCollision(orb, player)) {
          handleOrbPickup(orb);
        }
      });
      state.orbs = state.orbs.filter((orb) => !orb._remove);
    }

    function checkCollision(a, b) {
      const aRect = a.getBoundingClientRect();
      const bRect = b.getBoundingClientRect();
      const padding = state.perks.has("orbMagnet") ? 18 : 8;
      return !(
        aRect.right < bRect.left + padding ||
        aRect.left > bRect.right - padding ||
        aRect.bottom < bRect.top + padding ||
        aRect.top > bRect.bottom - padding
      );
    }

    function handleOrbPickup(orb) {
      orb._remove = true;
      orb.remove();
      if (orb.dataset.type === "damage") {
        handleHit();
        return;
      }
      if (orb.dataset.type === "curse") {
        state.energy = Math.max(0, state.energy - 20);
        state.slowTime = 2;
        handleHit(0.12);
        return;
      }
      state.streak += 1;
      registerObjective("good");
      if (orb.dataset.type === "heal") {
        state.aliveChance = Math.min(1, state.aliveChance + 0.18);
        addXp(6);
      }
      if (orb.dataset.type === "xp") {
        addXp(12);
      }
      if (orb.dataset.type === "energy") {
        state.energy = Math.min(maxEnergy(), state.energy + 30);
        addXp(6);
      }
      if (orb.dataset.type === "time") {
        state.slowTime = 4;
        addXp(8);
      }
      if (orb.dataset.type === "choice") {
        openChoiceOrb();
      }
      if (state.streak >= 5) {
        rescuePulse();
        state.streak = 0;
      }
    }

    function handleHit(amount = 0.25) {
      if (state.shielded) {
        state.shielded = false;
        player.classList.remove("shielded");
        flash.classList.add("active");
        setTimeout(() => flash.classList.remove("active"), 120);
        return;
      }
      const penalty = state.modifier?.name === "High Stakes" ? amount * 1.3 : amount;
      state.aliveChance -= penalty;
      state.streak = 0;
      flash.classList.add("active");
      setTimeout(() => flash.classList.remove("active"), 120);
      if (state.aliveChance <= 0) {
        endGame();
      }
    }

    function rescuePulse() {
      alertTitle.textContent = "Rescue Pulse!";
      alertText.textContent = "Your streak cleared nearby threats.";
      const playerRect = player.getBoundingClientRect();
      state.orbs.forEach((orb) => {
        if (orb.dataset.type === "damage" || orb.dataset.type === "curse") {
          const orbRect = orb.getBoundingClientRect();
          const distance = Math.hypot(orbRect.x - playerRect.x, orbRect.y - playerRect.y);
          if (distance < 150) {
            orb._remove = true;
            orb.remove();
          }
        }
      });
      setTimeout(() => {
        alertTitle.textContent = "Breathe. Stay alive.";
        alertText.textContent = "Move with WASD or arrows. Dodge bad orbs, collect good ones.";
      }, 1500);
    }

    function addXp(amount) {
      const multiplier = state.modifier?.name === "High Stakes" ? 2 : 1;
      state.xp += amount * multiplier;
      if (state.xp >= 100) {
        state.xp -= 100;
        state.energy = Math.min(maxEnergy(), state.energy + 20);
        state.aliveChance = Math.min(1, state.aliveChance + 0.1);
        state.legacyPoints += 1;
        saveLegacy();
      }
      registerObjective("streak");
    }

    function registerObjective(type) {
      const current = objectives[state.objectiveIndex];
      if (current.type === "nodash") return;
      if (current.type === "streak" && type === "streak") {
        current.progress = state.streak;
      }
      if (current.type === type) {
        current.progress = (current.progress || 0) + 1;
      }
      if ((current.progress || 0) >= current.target) {
        completeObjective();
      }
    }

    function completeObjective() {
      const current = objectives[state.objectiveIndex];
      alertTitle.textContent = "Objective cleared!";
      alertText.textContent = "Bonus energy + XP awarded.";
      state.energy = Math.min(maxEnergy(), state.energy + 35);
      state.aliveChance = Math.min(1, state.aliveChance + 0.15);
      addXp(20);
      current.progress = 0;
      state.objectiveIndex = (state.objectiveIndex + 1) % objectives.length;
      updateObjectiveText();
      setTimeout(() => {
        alertTitle.textContent = "Breathe. Stay alive.";
        alertText.textContent = "Move with WASD or arrows. Dodge bad orbs, collect good ones.";
      }, 1500);
    }

    function updateObjectiveText() {
      const current = objectives[state.objectiveIndex];
      objectiveText.innerHTML = `<strong>Objective:</strong> ${current.text}`;
    }

    function openChoiceOrb() {
      if (!state.allowChoices) return;
      state.allowChoices = false;
      choiceButtons.innerHTML = "";
      const options = [
        { label: "Instant heal +15%", action: () => gainStat("alive", 0.15) },
        { label: "Energy refill +40", action: () => gainStat("energy", 40) },
        { label: "XP surge +25", action: () => gainStat("xp", 25) },
        { label: "Risk: double speed, -10% life", action: () => {
          gainStat("speed", 20);
          handleHit(0.1);
        }},
      ];
      options.sort(() => Math.random() - 0.5).slice(0, 2).forEach((option) => {
        const button = document.createElement("button");
        button.textContent = option.label;
        button.addEventListener("click", () => {
          option.action();
          choiceOverlay.classList.remove("active");
          state.allowChoices = true;
        });
        choiceButtons.appendChild(button);
      });
      choiceOverlay.classList.add("active");
    }

    function triggerEvent(event) {
      eventChoices.innerHTML = "";
      eventTitle.textContent = event.title;
      eventText.textContent = event.text;
      event.choices.forEach((choice) => {
        const button = document.createElement("button");
        button.textContent = choice.text;
        button.addEventListener("click", () => {
          choice.effect();
          eventOverlay.classList.remove("active");
        });
        eventChoices.appendChild(button);
      });
      eventOverlay.classList.add("active");
    }

    function gainStat(type, amount) {
      if (type === "alive") state.aliveChance = Math.min(1, state.aliveChance + amount);
      if (type === "energy") state.energy = Math.min(maxEnergy(), state.energy + amount);
      if (type === "xp") addXp(amount);
      if (type === "speed") state.speed += amount;
      if (type === "legacy") {
        state.legacyPoints += amount;
        saveLegacy();
      }
    }

    function useDash() {
      if (state.dashCooldown > 0 || state.energy < 18) return;
      state.dashCooldown = 1.4;
      state.energy -= 18;
      const direction = getDirection();
      if (!direction) return;
      state.playerX += direction.x * state.speed * 0.6;
      state.playerY += direction.y * state.speed * 0.6;
      clampPlayer();
      updatePlayer();
      leaveTrail();
      if (objectives[state.objectiveIndex].type === "nodash") {
        objectives[state.objectiveIndex].progress = 0;
      }
    }

    function useShield() {
      if (state.shieldCooldown > 0 || state.energy < 30) return;
      state.shieldCooldown = 6;
      state.energy -= 30;
      state.shielded = true;
      player.classList.add("shielded");
      setTimeout(() => {
        state.shielded = false;
        player.classList.remove("shielded");
      }, 3200);
    }

    function useFocus() {
      if (state.focusCooldown > 0 || state.energy < 24) return;
      state.focusCooldown = 8;
      state.energy -= 24;
      state.slowTime = 3.5;
    }

    function maxEnergy() {
      return state.perks.has("extraEnergy") ? 115 : 100;
    }

    function clampPlayer() {
      const maxX = arena.clientWidth - player.clientWidth;
      const maxY = arena.clientHeight - player.clientHeight;
      state.playerX = Math.max(0, Math.min(state.playerX, maxX));
      state.playerY = Math.max(0, Math.min(state.playerY, maxY));
    }

    function getDirection() {
      let dx = 0;
      let dy = 0;
      if (keys.has("ArrowUp") || keys.has("w")) dy -= 1;
      if (keys.has("ArrowDown") || keys.has("s")) dy += 1;
      if (keys.has("ArrowLeft") || keys.has("a")) dx -= 1;
      if (keys.has("ArrowRight") || keys.has("d")) dx += 1;
      if (dx === 0 && dy === 0) return null;
      const magnitude = Math.hypot(dx, dy) || 1;
      return { x: dx / magnitude, y: dy / magnitude };
    }

    function updateMeters() {
      aliveMeter.style.transform = `scaleX(${state.aliveChance})`;
      scoreEl.textContent = `${Math.floor(state.score)}`;
      xpValue.textContent = `${Math.floor(state.xp)}`;
      energyValue.textContent = `${Math.floor(state.energy)}`;
      ageValue.textContent = `${Math.floor(state.age)}`;
    }

    function tick(timestamp) {
      if (!state.active) return;
      if (!state.lastTime) state.lastTime = timestamp;
      const delta = (timestamp - state.lastTime) / 1000;
      state.lastTime = timestamp;

      handleMovement(delta);
      moveOrbs(delta);

      const stage = stages.find((item) => state.age >= item.start && (!item.end || state.age < item.end));
      const staminaDrain = stage?.staminaDrain || 1;
      state.score += delta;
      state.age += delta * 0.4;
      state.aliveChance = Math.max(0, state.aliveChance - delta * 0.01);
      if (state.perks.has("slowDecay")) {
        state.aliveChance = Math.max(0, state.aliveChance + delta * 0.004);
      }
      state.energy = Math.min(maxEnergy(), state.energy + delta * (5 - staminaDrain * 0.8));
      state.dashCooldown = Math.max(0, state.dashCooldown - delta);
      state.shieldCooldown = Math.max(0, state.shieldCooldown - delta);
      state.focusCooldown = Math.max(0, state.focusCooldown - delta);
      state.slowTime = Math.max(0, state.slowTime - delta);

      state.orbTimer += delta;
      state.badOrbTimer += delta;
      state.difficultyTimer += delta;

      const goodRate = state.modifier?.name === "Golden Hour" ? 0.65 : 0.45;
      const badRate = state.modifier?.name === "Stormfall" ? 0.6 : 0.4;

      if (state.orbTimer > 1.1 - state.score * 0.002) {
        if (Math.random() < goodRate) spawnGoodOrb();
        state.orbTimer = 0;
      }

      if (state.badOrbTimer > 1.2 - state.score * 0.002) {
        if (Math.random() < badRate) spawnBadOrb();
        state.badOrbTimer = 0;
      }

      if (state.difficultyTimer > 15) {
        state.difficultyTimer = 0;
        alertTitle.textContent = "Intensity rising";
        alertText.textContent = "Bad orbs speed up. Keep moving.";
      }

      if (objectives[state.objectiveIndex].type === "nodash") {
        objectives[state.objectiveIndex].progress =
          (objectives[state.objectiveIndex].progress || 0) + delta;
        if (objectives[state.objectiveIndex].progress >= objectives[state.objectiveIndex].target) {
          completeObjective();
        }
      }

      const nextEvent = events[state.eventIndex];
      if (nextEvent && state.age >= nextEvent.age) {
        state.eventIndex += 1;
        triggerEvent(nextEvent);
      }

      setStage();
      updateMeters();

      if (state.aliveChance <= 0) {
        endGame();
        return;
      }

      requestAnimationFrame(tick);
    }

    function startGame() {
      state.active = true;
      state.score = 0;
      state.aliveChance = 1;
      state.energy = maxEnergy();
      state.xp = 0;
      state.age = 0;
      state.dashCooldown = 0;
      state.shieldCooldown = 0;
      state.focusCooldown = 0;
      state.shielded = false;
      state.slowTime = 0;
      state.orbs.forEach((orb) => orb.remove());
      state.orbs = [];
      state.lastTime = null;
      state.orbTimer = 0;
      state.badOrbTimer = 0;
      state.difficultyTimer = 0;
      state.streak = 0;
      state.objectiveIndex = 0;
      state.eventIndex = 0;
      state.allowChoices = true;
      objectives.forEach((objective) => { objective.progress = 0; });

      state.modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
      alertTitle.textContent = `Modifier: ${state.modifier.name}`;
      alertText.textContent = state.modifier.text;

      if (state.perks.has("starterShield")) {
        state.shielded = true;
        player.classList.add("shielded");
        setTimeout(() => {
          state.shielded = false;
          player.classList.remove("shielded");
        }, 2800);
      } else {
        player.classList.remove("shielded");
      }

      updateObjectiveText();
      startOverlay.classList.remove("active");
      gameOverOverlay.classList.remove("active");
      eventOverlay.classList.remove("active");
      choiceOverlay.classList.remove("active");
      resetPlayerPosition();
      updateMeters();
      requestAnimationFrame(tick);
    }

    function endGame() {
      state.active = false;
      finalScore.textContent = `You saved him for ${Math.floor(state.score)} seconds and earned ${state.legacyPoints} legacy points.`;
      gameOverOverlay.classList.add("active");
      saveLegacy();
    }

    function handleResize() {
      if (!state.active) return;
      resetPlayerPosition();
    }

    window.addEventListener("resize", handleResize);
    document.addEventListener("keydown", (event) => {
      keys.add(event.key);
      if (event.key === " " && state.active) {
        useDash();
      }
      if ((event.key === "e" || event.key === "E") && state.active) {
        useShield();
      }
      if ((event.key === "q" || event.key === "Q") && state.active) {
        useFocus();
      }
    });

    document.addEventListener("keyup", (event) => {
      keys.delete(event.key);
    });

    startBtn.addEventListener("click", startGame);
    restartBtn.addEventListener("click", startGame);

    loadLegacy();
    renderPerks();
    resetPlayerPosition();
  </script>
</body>
</html>
